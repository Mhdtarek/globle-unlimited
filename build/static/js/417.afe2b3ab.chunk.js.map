{"version":3,"file":"static/js/417.afe2b3ab.chunk.js","mappings":"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","sources":["components/Globe.tsx","util/centre.ts"],"sourcesContent":["import { useContext, useEffect, useRef, useState } from \"react\";\nimport ReactGlobe, { GlobeMethods } from \"react-globe.gl\";\nimport { Country } from \"../lib/country\";\nimport { findCentre } from \"../util/centre\";\nimport { answerCountry } from \"../util/answer\";\nimport { globeImg, turnGlobe } from \"../util/globe\";\nimport { ThemeContext } from \"../context/ThemeContext\";\nimport { getColour } from \"../util/colour\";\nimport { isMobile } from \"react-device-detect\";\nconst territoryData: Country[] = require(\"../data/territories.json\").features;\n\ntype Props = {\n  guesses: Country[];\n  globeRef: React.MutableRefObject<GlobeMethods>;\n};\n\nexport default function Globe({ guesses, globeRef }: Props) {\n  // State\n  const [places, setPlaces] = useState(guesses);\n\n  // Theme\n  const { nightMode, highContrast } = useContext(ThemeContext).theme;\n\n  // Globe size settings\n  const size = isMobile ? 320 : 600; // px on one side\n  const extraStyle = {\n    width: `${size}px`,\n    clipPath: `circle(${size / 2}px at ${size / 2}px ${size / 2}px)`,\n  };\n\n  // After each guess\n  useEffect(() => {\n    // Add territories to guesses to make shapes\n    const territories: Country[] = [];\n    guesses.forEach((guess) => {\n      const foundTerritories = territoryData.filter((territory) => {\n        return guess.properties.NAME === territory.properties.SOVEREIGNT;\n      });\n      if (foundTerritories) territories.push(...foundTerritories);\n    });\n    setPlaces(guesses.concat(territories));\n\n    // Turn globe to new spot\n    const controls: any = globeRef.current.controls();\n    controls.autoRotate = false;\n    const newGuess = [...guesses].pop();\n    if (newGuess) {\n      const newSpot = findCentre(newGuess);\n      turnGlobe(newSpot, globeRef);\n    }\n  }, [guesses, globeRef]);\n\n  // On first render\n  useEffect(() => {\n    const controls: any = globeRef.current.controls();\n    controls.autoRotate = true;\n    controls.autoRotateSpeed = 1;\n    setTimeout(() => {\n      globeRef.current.pointOfView({ lat: 0, lng: 0, altitude: 1.5 });\n    }, 400);\n  }, [globeRef]);\n\n  // Stop rotate on drag\n  const containerRef = useRef<HTMLDivElement>(null!);\n  useEffect(() => {\n    const controls: any = globeRef.current.controls();\n    containerRef.current.addEventListener(\"mouseup\", () => {\n      controls.autoRotate = false;\n    });\n    containerRef.current.addEventListener(\"touchend\", () => {\n      controls.autoRotate = false;\n    });\n  }, [globeRef]);\n\n  // Label colour\n  function getLabel(country: Country) {\n    const name = country.properties.ADMIN;\n    const prox = country.proximity;\n    const dayColour = prox < 750_000 ? \"gray-300\" : \"gray-900\";\n    const nightColour = \"gray-300\";\n    const label = `<b class=\"text-${dayColour} dark:text-${nightColour}\">${name}</b>`;\n    return label;\n  }\n\n  // Polygon altitude\n  function getAltitude(country: Country) {\n    if (!highContrast || country.properties.TYPE === \"Territory\") return 0.01;\n    const prox = country.proximity;\n    let proxFraction = prox / 2_000_000;\n    proxFraction = Math.min(Math.max(proxFraction, 0.01), 0.95);\n    let alt = (1 - proxFraction) / 10;\n    return alt;\n  }\n\n  function zoom(z: number) {\n    const controls: any = globeRef.current.controls();\n    controls.autoRotate = false;\n    const coords = globeRef.current.pointOfView();\n    const { altitude } = globeRef.current.pointOfView();\n    coords[\"altitude\"] = Math.max(altitude + z, 0.05);\n    globeRef.current.pointOfView(coords, 250);\n  }\n\n  const btnFill = nightMode ? \"bg-[#582679]\" : \"bg-[#F3BC63]\";\n  const btnBorder = nightMode ? \"border-[#350a46]\" : \"border-[#FF8E57]\";\n  const btnText = nightMode ? \"text-white font-bold\" : \"\";\n\n  return (\n    <div>\n      <div\n        ref={containerRef}\n        className=\"globe mx-auto cursor-grab text-center select-none\"\n        style={extraStyle}\n      >\n        <ReactGlobe\n          className=\"select-none decoration-transparent cursor-grab \"\n          style={{ \"-webkit-tap-highlight-color\": \"transparent\" }}\n          ref={globeRef}\n          // globeImageUrl={`images/earth-${nightMode ? \"night\" : \"day\"}.webp`}\n          globeImageUrl={globeImg(nightMode)}\n          width={size}\n          height={size}\n          backgroundColor=\"#00000000\"\n          polygonsData={places}\n          polygonCapColor={(c) =>\n            // @ts-ignore\n            getColour(c, answerCountry, nightMode, highContrast)\n          }\n          // @ts-ignore\n          polygonLabel={getLabel}\n          // @ts-ignore\n          polygonAltitude={getAltitude}\n          polygonSideColor=\"blue\"\n          onGlobeClick={(d) => turnGlobe(d, globeRef)}\n          onPolygonClick={(p, e, c) => turnGlobe(c, globeRef)}\n          polygonStrokeColor=\"#00000000\"\n          atmosphereColor={nightMode ? \"rgba(63, 201, 255)\" : \"lightskyblue\"}\n        />\n      </div>\n      {isMobile && (\n        <div className=\"w-full flex justify-between text-md \">\n          <button\n            className={`border-[1px] rounded-md select-none ${btnText} ${btnFill} px-4 ${btnBorder}`}\n            onTouchStart={() => zoom(0.2)}\n          >\n            -\n          </button>\n          <button\n            className={`border-[1px] rounded-md select-none ${btnText} ${btnFill} px-4 ${btnBorder}`}\n            onTouchStart={() => zoom(-0.2)}\n          >\n            +\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n","import { Country } from '../lib/country';\n\nexport function findCentre(country: Country) {\n  const { bbox } = country;\n  const [lng1, lat1, lng2, lat2] = bbox;\n  let latitude = (lat1 + lat2) / 2;\n  const longitude = (lng1 + lng2) / 2;\n  return {lat: latitude, lng: longitude};\n}\n\n\n"],"names":["territoryData","require","Globe","guesses","globeRef","useState","places","setPlaces","useContext","ThemeContext","theme","nightMode","highContrast","size","isMobile","extraStyle","width","clipPath","useEffect","territories","forEach","guess","foundTerritories","filter","territory","properties","NAME","SOVEREIGNT","push","concat","current","controls","autoRotate","newGuess","pop","newSpot","findCentre","turnGlobe","autoRotateSpeed","setTimeout","pointOfView","lat","lng","altitude","containerRef","useRef","zoom","z","coords","Math","max","addEventListener","btnFill","btnBorder","btnText","ref","className","style","globeImageUrl","globeImg","height","backgroundColor","polygonsData","polygonCapColor","c","getColour","answerCountry","polygonLabel","country","name","ADMIN","prox","proximity","polygonAltitude","TYPE","proxFraction","min","polygonSideColor","onGlobeClick","d","onPolygonClick","p","e","polygonStrokeColor","atmosphereColor","onTouchStart","bbox","lng1","lat1","lng2"],"sourceRoot":""}