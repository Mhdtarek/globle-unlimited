{"version":3,"file":"static/js/417.afe2b3ab.chunk.js","mappings":"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","sources":["components/Globe.tsx","util/centre.ts"],"sourcesContent":["import { useContext, useEffect, useRef, useState } from \"react\";\r\nimport ReactGlobe, { GlobeMethods } from \"react-globe.gl\";\r\nimport { Country } from \"../lib/country\";\r\nimport { findCentre } from \"../util/centre\";\r\nimport { answerCountry } from \"../util/answer\";\r\nimport { globeImg, turnGlobe } from \"../util/globe\";\r\nimport { ThemeContext } from \"../context/ThemeContext\";\r\nimport { getColour } from \"../util/colour\";\r\nimport { isMobile } from \"react-device-detect\";\r\nconst territoryData: Country[] = require(\"../data/territories.json\").features;\r\n\r\ntype Props = {\r\n  guesses: Country[];\r\n  globeRef: React.MutableRefObject<GlobeMethods>;\r\n};\r\n\r\nexport default function Globe({ guesses, globeRef }: Props) {\r\n  // State\r\n  const [places, setPlaces] = useState(guesses);\r\n\r\n  // Theme\r\n  const { nightMode, highContrast } = useContext(ThemeContext).theme;\r\n\r\n  // Globe size settings\r\n  const size = isMobile ? 320 : 600; // px on one side\r\n  const extraStyle = {\r\n    width: `${size}px`,\r\n    clipPath: `circle(${size / 2}px at ${size / 2}px ${size / 2}px)`,\r\n  };\r\n\r\n  // After each guess\r\n  useEffect(() => {\r\n    // Add territories to guesses to make shapes\r\n    const territories: Country[] = [];\r\n    guesses.forEach((guess) => {\r\n      const foundTerritories = territoryData.filter((territory) => {\r\n        return guess.properties.NAME === territory.properties.SOVEREIGNT;\r\n      });\r\n      if (foundTerritories) territories.push(...foundTerritories);\r\n    });\r\n    setPlaces(guesses.concat(territories));\r\n\r\n    // Turn globe to new spot\r\n    const controls: any = globeRef.current.controls();\r\n    controls.autoRotate = false;\r\n    const newGuess = [...guesses].pop();\r\n    if (newGuess) {\r\n      const newSpot = findCentre(newGuess);\r\n      turnGlobe(newSpot, globeRef);\r\n    }\r\n  }, [guesses, globeRef]);\r\n\r\n  // On first render\r\n  useEffect(() => {\r\n    const controls: any = globeRef.current.controls();\r\n    controls.autoRotate = true;\r\n    controls.autoRotateSpeed = 1;\r\n    setTimeout(() => {\r\n      globeRef.current.pointOfView({ lat: 0, lng: 0, altitude: 1.5 });\r\n    }, 400);\r\n  }, [globeRef]);\r\n\r\n  // Stop rotate on drag\r\n  const containerRef = useRef<HTMLDivElement>(null!);\r\n  useEffect(() => {\r\n    const controls: any = globeRef.current.controls();\r\n    containerRef.current.addEventListener(\"mouseup\", () => {\r\n      controls.autoRotate = false;\r\n    });\r\n    containerRef.current.addEventListener(\"touchend\", () => {\r\n      controls.autoRotate = false;\r\n    });\r\n  }, [globeRef]);\r\n\r\n  // Label colour\r\n  function getLabel(country: Country) {\r\n    const name = country.properties.ADMIN;\r\n    const prox = country.proximity;\r\n    const dayColour = prox < 750_000 ? \"gray-300\" : \"gray-900\";\r\n    const nightColour = \"gray-300\";\r\n    const label = `<b class=\"text-${dayColour} dark:text-${nightColour}\">${name}</b>`;\r\n    return label;\r\n  }\r\n\r\n  // Polygon altitude\r\n  function getAltitude(country: Country) {\r\n    if (!highContrast || country.properties.TYPE === \"Territory\") return 0.01;\r\n    const prox = country.proximity;\r\n    let proxFraction = prox / 2_000_000;\r\n    proxFraction = Math.min(Math.max(proxFraction, 0.01), 0.95);\r\n    let alt = (1 - proxFraction) / 10;\r\n    return alt;\r\n  }\r\n\r\n  function zoom(z: number) {\r\n    const controls: any = globeRef.current.controls();\r\n    controls.autoRotate = false;\r\n    const coords = globeRef.current.pointOfView();\r\n    const { altitude } = globeRef.current.pointOfView();\r\n    coords[\"altitude\"] = Math.max(altitude + z, 0.05);\r\n    globeRef.current.pointOfView(coords, 250);\r\n  }\r\n\r\n  const btnFill = nightMode ? \"bg-[#582679]\" : \"bg-[#F3BC63]\";\r\n  const btnBorder = nightMode ? \"border-[#350a46]\" : \"border-[#FF8E57]\";\r\n  const btnText = nightMode ? \"text-white font-bold\" : \"\";\r\n\r\n  return (\r\n    <div>\r\n      <div\r\n        ref={containerRef}\r\n        className=\"globe mx-auto cursor-grab text-center select-none\"\r\n        style={extraStyle}\r\n      >\r\n        <ReactGlobe\r\n          className=\"select-none decoration-transparent cursor-grab \"\r\n          style={{ \"-webkit-tap-highlight-color\": \"transparent\" }}\r\n          ref={globeRef}\r\n          // globeImageUrl={`images/earth-${nightMode ? \"night\" : \"day\"}.webp`}\r\n          globeImageUrl={globeImg(nightMode)}\r\n          width={size}\r\n          height={size}\r\n          backgroundColor=\"#00000000\"\r\n          polygonsData={places}\r\n          polygonCapColor={(c) =>\r\n            // @ts-ignore\r\n            getColour(c, answerCountry, nightMode, highContrast)\r\n          }\r\n          // @ts-ignore\r\n          polygonLabel={getLabel}\r\n          // @ts-ignore\r\n          polygonAltitude={getAltitude}\r\n          polygonSideColor=\"blue\"\r\n          onGlobeClick={(d) => turnGlobe(d, globeRef)}\r\n          onPolygonClick={(p, e, c) => turnGlobe(c, globeRef)}\r\n          polygonStrokeColor=\"#00000000\"\r\n          atmosphereColor={nightMode ? \"rgba(63, 201, 255)\" : \"lightskyblue\"}\r\n        />\r\n      </div>\r\n      {isMobile && (\r\n        <div className=\"w-full flex justify-between text-md \">\r\n          <button\r\n            className={`border-[1px] rounded-md select-none ${btnText} ${btnFill} px-4 ${btnBorder}`}\r\n            onTouchStart={() => zoom(0.2)}\r\n          >\r\n            -\r\n          </button>\r\n          <button\r\n            className={`border-[1px] rounded-md select-none ${btnText} ${btnFill} px-4 ${btnBorder}`}\r\n            onTouchStart={() => zoom(-0.2)}\r\n          >\r\n            +\r\n          </button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","import { Country } from '../lib/country';\r\n\r\nexport function findCentre(country: Country) {\r\n  const { bbox } = country;\r\n  const [lng1, lat1, lng2, lat2] = bbox;\r\n  let latitude = (lat1 + lat2) / 2;\r\n  const longitude = (lng1 + lng2) / 2;\r\n  return {lat: latitude, lng: longitude};\r\n}\r\n\r\n\r\n"],"names":["territoryData","require","Globe","guesses","globeRef","useState","places","setPlaces","useContext","ThemeContext","theme","nightMode","highContrast","size","isMobile","extraStyle","width","clipPath","useEffect","territories","forEach","guess","foundTerritories","filter","territory","properties","NAME","SOVEREIGNT","push","concat","current","controls","autoRotate","newGuess","pop","newSpot","findCentre","turnGlobe","autoRotateSpeed","setTimeout","pointOfView","lat","lng","altitude","containerRef","useRef","zoom","z","coords","Math","max","addEventListener","btnFill","btnBorder","btnText","ref","className","style","globeImageUrl","globeImg","height","backgroundColor","polygonsData","polygonCapColor","c","getColour","answerCountry","polygonLabel","country","name","ADMIN","prox","proximity","polygonAltitude","TYPE","proxFraction","min","polygonSideColor","onGlobeClick","d","onPolygonClick","p","e","polygonStrokeColor","atmosphereColor","onTouchStart","bbox","lng1","lat1","lng2"],"sourceRoot":""}